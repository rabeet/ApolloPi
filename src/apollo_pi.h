//////////////////////////////////////////////////////////////////////////////
// Model: apollo_pi.qm
// File:  ./src/apollo_pi.h
//
// This file has been generated automatically by QP Modeler (QM).
// DO NOT EDIT THIS FILE MANUALLY.
//
// Please visit www.state-machine.com/qm for more information.
//////////////////////////////////////////////////////////////////////////////
#ifndef apollo_pi_h
#define apollo_pi_h

#include "qp_port.h"
#include "web_socket_frame.h"

#include <netinet/in.h>
#include <json/json.h>

namespace ApolloPi {

#define SERVER_QUEUE_SIZE 50     // FIXME: some of these are arbitrarily large
#define STATUS_LED_QUEUE_SIZE 5
#define DISPATCHER_QUEUE_SIZE 50
#define WIFI_DONGLE_QUEUE_SIZE 10
#define SMALL_POOL_SIZE 50

#define BACKLOG_QUEUE 0
#define BUF_SIZE 1024   // 1 KB

/* wireless interface name */
#define IW_NAME "wlan0"

enum ApolloPiSignals {
    CONNECTED_SIG = QP::Q_USER_SIG,
    DISCONNECTED_SIG,
    MAX_PUB_SIG,
    ACCEPT_SIG,
    SEND_SIG,
    RECV_SIG,
    DISPATCH_MESSAGE_SIG,
    UPDATE_WIFI_DONGLE_SIG,
    UPDATE_MOTORS_SIG,
    UPDATE_MOTOR_SPEED_SIG,
    TOGGLE_HEADLIGHTS_SIG,
    MAX_SIG
};

/* server async handler function */
void connect_handler(int signum);

/* client IO handler */
void client_handler(int signum);

/* AOs */
// @(/1/0) ...................................................................
/// This Active Object communicates with the operator (client), sending updates from the devices and receiving commands from the operator.
/// 
/// 
class WebSocketServer : public QP::QActive {
private:
    /// This is the file descriptor that represents the listening (passive) socket. When a client tries to connect, a SIGIO signal is handled via accept_handler(). From the accept handler an AcceptEvt is posted to the server
    int socket_fd_;
    int client_fd_;
    int port_;
    bool connected_;
    sockaddr_in server_addr_;
    sockaddr_in client_addr_;

public:
    /// Constructs the WebSocketServer. The default port is 80, however, appropriate permission are required to bind to this port.
    WebSocketServer(int port);
    void set_connected(bool status);
    bool get_connected();
    /// Wraps listen syscall.
    void listen();
    bool accept();
    /// Wraps the recv() call. Creates a new WebSocketFrame return its pointers.
    WebSocketFrame * receive();
    void send(WebSocketFrame * frame);
    /// Returns the server socket file descriptor.
    int get_socket_fd();
    int get_client_fd();
    void close();

private:
    /// Receives the HTTP header from the socket.
    char * receive_hdr();
    bool handshake();

protected:
    static QP::QState initial(WebSocketServer * const me, QP::QEvt const * const e);

    /// The server is listening for an operator (client) to connect.
    static QP::QState listening(WebSocketServer * const me, QP::QEvt const * const e);

    /// The Apollo Pi is active when in this state. An operator is connected and may send and receive messages.
    /// 
    /// To send a message to the operator, post a SendEvt to the server with the data (JSON string) as an event parameter. For example:
    /// 
    /// SendEvt *se = Q_NEW(SendEvt, SEND_SIG);
    /// se->data = json_data;
    /// AO_WebSocketServer->postFIFO(se);
    /// 
    /// 
    static QP::QState connected(WebSocketServer * const me, QP::QEvt const * const e);
};
// @(/1/1) ...................................................................
/// This Active Object dispatches control events to the hardware devices (e.g. MotorController, StatusLed, Camera).
class Dispatcher : public QP::QActive {
public:
    Dispatcher();

private:
    /// Sends json_msg to the appropriate AO.
    /// 
    /// Returns true on failure.
    bool dispatch_message(const char * target, json_object * json_msg);

protected:
    static QP::QState initial(Dispatcher * const me, QP::QEvt const * const e);
    static QP::QState active(Dispatcher * const me, QP::QEvt const * const e);
};
// @(/1/2) ...................................................................
/// Represents a Wi-Fi dongle attached to the Raspberry Pi. This Active Object updates its status periodically by sending the Wi-Fi signal quality retreived from an ioctl() on the socket
/// 
/// TODO: Implement a failsafe method for fixing the situation when the device goes out of range.
/// 
/// TODO: The operator should also be notified when the signal quality is getting low.
class WifiDongle : public QP::QActive {
private:
    QP::QTimeEvt updateEvt;
    /// Update interval, in seconds, for sending update message to the operator.
    int update_ival_;
    char json_status_[BUF_SIZE];

public:
    WifiDongle();

private:
    /// Updates the current status of the Wi-Fi connection, and returns a formatted JSON string to send to the operator.
    char * update_status();

public:
    void update();

protected:
    static QP::QState initial(WifiDongle * const me, QP::QEvt const * const e);
    static QP::QState active(WifiDongle * const me, QP::QEvt const * const e);

    /// Inactive state for when the device is not connected.
    static QP::QState inactive(WifiDongle * const me, QP::QEvt const * const e);
};
// @(/1/4) ...................................................................
/// The StatusLed state machine represents the physical LED lights on the rover. When no operator is connected, it is red. When an operator is connected, it is green.
class StatusLed : public QP::QActive {
public:
    StatusLed();

private:
    void red_on();
    void green_on();

protected:
    static QP::QState initial(StatusLed * const me, QP::QEvt const * const e);
    static QP::QState red(StatusLed * const me, QP::QEvt const * const e);
    static QP::QState green(StatusLed * const me, QP::QEvt const * const e);
};

/* Events */
// @(/3/0) ...................................................................
/// This event is posted by a sigaction handler, accept_handler(), when a client tries to connect to the socket.
class AcceptEvt : public QP::QEvt {};
// @(/3/1) ...................................................................
class SendEvt : public QP::QEvt {
private:
    /// The JSON string of text, encapsulated in a frame, to be sent to the operator.
    WebSocketFrame * frame_;

public:
    /// Sets the data string for the event.
    /// 
    /// TODO: Should the buffer be a deep copy, or just a pointer to the original buffer? How will you handle memory management (when is it safe to release the buffer)?
    void set_frame(WebSocketFrame * frame);
    WebSocketFrame * get_frame();
    /// Deallocated the char buffer.
    void dealloc();
};
// @(/3/2) ...................................................................
class RecvEvt : public QP::QEvt {};
// @(/3/3) ...................................................................
class ConnectedEvt : public QP::QEvt {};
// @(/3/4) ...................................................................
class DisconnectedEvt : public QP::QEvt {};
// @(/3/5) ...................................................................
class DispatchEvt : public QP::QEvt {
private:
    char * message_;

public:
    /// Returns the message (should be a JSON string) to be interpretted, then dispatched to the appropriate object.
    char * get_message();
    void set_message(char * msg);
};
// @(/3/6) ...................................................................
/// This event contains data for controller motors. The data is interpretted by the MotorController AO.
class MotorControllerEvt : public QP::QEvt {
private:
    /// Represents the speed and direction of the left motor.
    int8_t left_speed_;
    /// Represents the speed and direction of the right motor.
    int8_t right_speed_;

public:
    void set_left_speed(int8_t value);
    void set_right_speed(int8_t value);
    int8_t get_left_speed();
    int8_t get_right_speed();
};

/* opaque pointer to AOs */
extern QP::QActive * const AO_WebSocketServer;
extern QP::QActive * const AO_StatusLed;
extern QP::QActive * const AO_Dispatcher;
extern QP::QActive * const AO_WifiDongle;


}

#endif /* apollo_pi_h */
