//////////////////////////////////////////////////////////////////////////////
// Model: apollo_pi.qm
// File:  ./src/web_socket_server.cpp
//
// This file has been generated automatically by QP Modeler (QM).
// DO NOT EDIT THIS FILE MANUALLY.
//
// Please visit www.state-machine.com/qm for more information.
//////////////////////////////////////////////////////////////////////////////
#include "apollo_pi.h" // for declaration
#include "qp_port.h"
#include "web_socket_frame.h"

#include <iostream>
#include <cstring>
#include <cstdlib>

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <signal.h>
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
#include <openssl/sha.h>
#include <openssl/hmac.h>
#include <openssl/evp.h>
#include <openssl/bio.h>
#include <openssl/buffer.h>
#include <sys/epoll.h>

namespace ApolloPi {

#define GUID "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"

/* sets up asynch signal handler */
void async_setup()
{
    struct sigaction connect_action;

    std::memset(&connect_action, 0, sizeof(connect_action));

    connect_action.sa_handler = connect_handler;
    sigemptyset(&connect_action.sa_mask);
    connect_action.sa_flags = 0;

    if(sigaction(SIGIO, &connect_action, NULL) < 0)
    {
        perror("sigaction()");
        exit(EXIT_FAILURE);
    }
}

char * base64(const unsigned char * input, int length)
{
    BIO *bmem, *b64;
    BUF_MEM *bptr;
    b64 = BIO_new(BIO_f_base64());
    bmem = BIO_new(BIO_s_mem());
    b64 = BIO_push(b64, bmem);
    BIO_write(b64, input, length);
    BIO_flush(b64);
    BIO_get_mem_ptr(b64, &bptr);

    char * buff = (char *)malloc(bptr->length+1);
    memcpy(buff, bptr->data, bptr->length);
    buff[bptr->length] = 0;

    BIO_free_all(b64);

    return buff;
}

static WebSocketServer l_server(80); // the server Active Object
QP::QActive * const AO_WebSocketServer = (QP::QActive *)&l_server;

// @(/1/0) ...................................................................
// @(/1/0/6) .................................................................
WebSocketServer::WebSocketServer(int port) 
  : QActive(Q_STATE_CAST(&WebSocketServer::initial)),
    port_(port),
    connected_(false)
{
    /* create a TCP socket */
    socket_fd_ = socket(AF_INET, SOCK_STREAM, 0);

    /* zero out address structures */
    std::memset((char *) &server_addr_, 0, sizeof(server_addr_));

    /* initialize server_addr structure */
    server_addr_.sin_family      = AF_INET;
    server_addr_.sin_port        = htons(port_);
    server_addr_.sin_addr.s_addr = INADDR_ANY;

    /* attempt to bind to a port -- must be super user if port < 1024 */
    std::cout << "Binding...";

    if (bind(socket_fd_, (sockaddr*) &server_addr_, sizeof(server_addr_)) < 0)
    {
        perror("bind()");
        exit(EXIT_FAILURE);
    }

    if(fcntl(socket_fd_, F_SETOWN, getpid()) < 0)
    {
        perror("F_SETOWN");
        exit(EXIT_FAILURE);
    }

    if(fcntl(socket_fd_, F_SETFL, O_NONBLOCK | FASYNC) < 0)
    {
        perror("F_SETFL");
        exit(EXIT_FAILURE);
    }
}

// @(/1/0/7) .................................................................
void WebSocketServer::set_connected(bool status) {
    connected_ = status;
}
// @(/1/0/8) .................................................................
bool WebSocketServer::get_connected() {
    return connected_;
}
// @(/1/0/9) .................................................................
void WebSocketServer::listen() {
    if(::listen(socket_fd_, BACKLOG_QUEUE) < 0)
    {
        perror("listen()");
        exit(EXIT_FAILURE);
    }
}
// @(/1/0/10) ................................................................
bool WebSocketServer::accept() {
    /* wait for a client to connect -- blocks while waiting */
    socklen_t client_len = sizeof(client_addr_);
    client_fd_ = ::accept(socket_fd_, (sockaddr *)&client_addr_, &client_len);

    if (client_fd_ < 0)
    {
        std::cerr << "ERROR: Could not accept new client." << std::endl;
        return false;
    }

    /* set async flag */
    if (fcntl(client_fd_, F_SETFL, FASYNC) < 0)
    {
        std::cerr << "client_fd_ SETFL: " << strerror(errno) << std::endl;
        exit(EXIT_FAILURE);
    }

    /* let this process receive signals on client_fd_ */
    if (fcntl(client_fd_, F_SETOWN, getpid()) < 0)
    {
        std::cerr << "client_fd_ SETOWN: " << strerror(errno) << std::endl;
        exit(EXIT_FAILURE);
    }
}
// @(/1/0/11) ................................................................
WebSocketFrame * WebSocketServer::receive() {
    char *buf = new char[BUF_SIZE];

    std::memset(buf, 0, BUF_SIZE);

    int n = recv(client_fd_, buf, BUF_SIZE, 0);

    if (n == 0)
    {
        // TODO close, cleanup, transition to listening
        buf[0] = 0x88; // close opcode
        buf[1] = 0x00;
        buf[2] = '\0';

        return WebSocketFrame::proc_frame(buf, 2);
    }
    else if(n < 0)
    {
        perror(NULL);
        exit(EXIT_FAILURE);
    }

    WebSocketFrame *frame =
        WebSocketFrame::proc_frame(buf, n);

    uint64_t len = frame->get_payload_len();

    // cleanup
    delete [] buf;

    return frame; // don't forget to dealloc from end point
}
// @(/1/0/12) ................................................................
void WebSocketServer::send(WebSocketFrame * frame) {
    // TODO: Frame data

    int n = ::send(client_fd_, frame->get_frame(),
        frame->get_len(), 0);

    if (n < 0)
    {
        std::cout << "Error sending." << std::endl;
        exit(EXIT_FAILURE);
    }
    else if (n == 0)
    {
        // ??
    }
}
// @(/1/0/13) ................................................................
int WebSocketServer::get_socket_fd() {
    return socket_fd_;
}
// @(/1/0/14) ................................................................
int WebSocketServer::get_client_fd() {
    return client_fd_;
}
// @(/1/0/15) ................................................................
void WebSocketServer::close() {
    ::close(client_fd_);

    DisconnectedEvt *de
        = Q_NEW(DisconnectedEvt, DISCONNECTED_SIG);

    QP::QF::publish(de);
}
// @(/1/0/16) ................................................................
char * WebSocketServer::receive_hdr() {
    char *buf = new char[BUF_SIZE];

    int n = recv(client_fd_, buf, BUF_SIZE, 0);

    if (n == -1)
    {
        perror("receive_hdr()");
        return NULL;
    }
    else if( n == 0 )
    {
        std::cout << "Did not receive header." << std::endl;
        return NULL;
    }

    return buf;
}
// @(/1/0/17) ................................................................
bool WebSocketServer::handshake() {
    /*
     * Now, we need to validate the WebSocket connection with client
     * per the RFC 6455.
     */
    char * recvd = receive_hdr();

    if (recvd == NULL)
    {
        std::cout << "Server: Header was null" << std::endl;
        return false;
    }

    std::cout << "Server: Received header ("
        << std::strlen(recvd) << ") bytes" << std::endl;

    char s[BUF_SIZE];

    std::strcpy(s, recvd);

    // dealloc receive buffer
    delete[] recvd;

    std::string header(s);

    std::cout << std::endl << "HTTP Header:" << std::endl << header << std::endl;

    /* parse the header */

    // FIXME All this does is find the Sec-WebSocket-Key value...
    // TODO verify valid header values

    // this next part is definitely hacky and error-prone
    int key_idx = header.find("Sec-WebSocket-Key:") + 19;
    std::string str_key = header.substr(key_idx, 24);

    std::cout << "Sec-WebSocket-Key: " << str_key << "END" << std::endl;

    // sha-1 key+GUID
    unsigned char hash[24];
    std::memset(hash, 0, 24);

    str_key.append(GUID);

    SHA1(reinterpret_cast<const unsigned char*>(str_key.c_str()),
            str_key.length(), hash);
    hash[20] = '\0';
    char * accept_b64 = base64(hash, 20);

    std::cout << "Sec-WebSocket-Accept: " << accept_b64 << std::endl;

    // send back an Upgrade/Accept header
    std::string accept_hdr(
            "HTTP/1.1 101 Switching Protocols\r\n"
            "Upgrade: websocket\r\n"
            "Connection: Upgrade\r\n"
            "Sec-WebSocket-Accept: " + std::string(accept_b64) + "\r\n");

    // send accept header
    if (::send(client_fd_, accept_hdr.c_str(), accept_hdr.length(), 0))
    {
        std::cout << "Sent accept header." << std::endl;
        return true;
    }
    else
    {
        return false;
    }

}
// @(/1/0/18) ................................................................
// @(/1/0/18/0)
QP::QState WebSocketServer::initial(WebSocketServer * const me, QP::QEvt const * const e) {
    std::cout << "Server initial transition" << std::endl;
    return Q_TRAN(&WebSocketServer::listening);
}
// @(/1/0/18/1) ..............................................................
QP::QState WebSocketServer::listening(WebSocketServer * const me, QP::QEvt const * const e) {
    QP::QState status;
    switch (e->sig) {
        // @(/1/0/18/1)
        case Q_ENTRY_SIG: {
            async_setup(); // defined in web_socket_server.cpp

            me->listen();

            std::cout << "Server: Listening..." << std::endl;
            status = Q_HANDLED();
            break;
        }
        // @(/1/0/18/1/0)
        case ACCEPT_SIG: {
            std::cout << "Creating socket..." << std::endl;

            me->accept();

            std::cout << "Attempting handshake..." << std::endl;

            if (me->handshake())
            {
                me->set_connected(true);
            }
            /*
            AcceptEvt:

            Create client_fd
            Attempt to read HTTP header
                Timeout 5 seconds
                return false
            Parse HTTP header
                Create HttpHeader object (dictionary)
            Check the following:
                Verify source (site) is ours
                Verify resource (GET /rover)
                    TODO: password
                Get Key
                Process key
                    accept_key = base64( SHA1(key+GUID))
                Create HttpResponse
                Add accept_key to the header
                Send back header
                return true
            */
            // @(/1/0/18/1/0/0)
            if (me->get_connected()) {
                struct sigaction client_action;
                std::memset(&client_action, 0, sizeof(client_action));

                client_action.sa_handler = client_handler;
                sigemptyset(&client_action.sa_mask);
                client_action.sa_flags = 0;

                if(sigaction(SIGIO, &client_action, NULL) < 0)
                {
                    perror("sigaction()");
                    exit(EXIT_FAILURE);
                }
                status = Q_TRAN(&WebSocketServer::connected);
            }
            // @(/1/0/18/1/0/1)
            else {
                std::cout << "Server: handshake failed" << std::endl;
                async_setup();
                status = Q_TRAN(&WebSocketServer::listening);
            }
            break;
        }
        default: {
            status = Q_SUPER(&QHsm::top);
            break;
        }
    }
    return status;
}
// @(/1/0/18/2) ..............................................................
QP::QState WebSocketServer::connected(WebSocketServer * const me, QP::QEvt const * const e) {
    QP::QState status;
    switch (e->sig) {
        // @(/1/0/18/2)
        case Q_ENTRY_SIG: {
            std::cout << "Server: Connected" << std::endl;

            // subscribe to DISCONNECTED_SIG
            me->subscribe(DISCONNECTED_SIG);

            ConnectedEvt *ce;

            ce = Q_NEW(ConnectedEvt, CONNECTED_SIG);

            std::cout << "Publishing CONNECTED_SIG" << std::endl;
            QP::QF::publish(ce);
            status = Q_HANDLED();
            break;
        }
        // @(/1/0/18/2/0)
        case SEND_SIG: {
            WebSocketFrame *frame
                = ((SendEvt *)e)->get_frame();

            // send then dealloc
            me->send(frame);

            ((SendEvt *)e)->dealloc();
            status = Q_HANDLED();
            break;
        }
        // @(/1/0/18/2/1)
        case RECV_SIG: {
            WebSocketFrame *frame = me->receive();

            uint64_t payload_len = frame->get_payload_len();
            char *msg = new char[payload_len];

            std::memset(msg, 0, payload_len);

            switch (frame->get_opcode())
            {
                case TEXT_FRAME: {
                    DispatchEvt *de = Q_NEW(DispatchEvt, DISPATCH_MESSAGE_SIG);
                    std::strcpy(msg, frame->get_payload());
                    de->set_message(msg);

                    AO_Dispatcher->postFIFO(de);
                    break;
                }
                //case ??: {

              //}
                default: {
                    std::cout << "Closing" << std::endl;
                    me->close();
                    break;
                }
            }

            delete frame;
            status = Q_HANDLED();
            break;
        }
        // @(/1/0/18/2/2)
        case DISCONNECTED_SIG: {
            status = Q_TRAN(&WebSocketServer::listening);
            break;
        }
        default: {
            status = Q_SUPER(&QHsm::top);
            break;
        }
    }
    return status;
}


// @(/3/1) ...................................................................
// @(/3/1/1) .................................................................
void SendEvt::set_frame(WebSocketFrame * frame) {
    frame_ = frame;
}
// @(/3/1/2) .................................................................
WebSocketFrame * SendEvt::get_frame() {
    return frame_;
}
// @(/3/1/3) .................................................................
void SendEvt::dealloc() {
    delete frame_;
}

void connect_handler(int signum)
{
    std::cout << "A client is trying to connect..." << std::endl;
    AcceptEvt *ae = Q_NEW(AcceptEvt, ACCEPT_SIG);

    AO_WebSocketServer->postFIFO(ae);
}

void client_handler(int signum)
{
    std::cout << "SIGIO on client socket" << std::endl;

    // assume input event is on client socket
    RecvEvt *re = Q_NEW(RecvEvt, RECV_SIG);
    AO_WebSocketServer->postFIFO(re);
}

}
