//////////////////////////////////////////////////////////////////////////////
// Model: apollo_pi.qm
// File:  ./src/motor.cpp
//
// This file has been generated automatically by QP Modeler (QM).
// DO NOT EDIT THIS FILE MANUALLY.
//
// Please visit www.state-machine.com/qm for more information.
//////////////////////////////////////////////////////////////////////////////
#include "qp_port.h"
#include "rover.h"
#include <wiringPi.h>

#include <iostream>

namespace ApolloPi {

// @(/2/1) ...................................................................
// @(/2/1/2) .................................................................
Motor::Motor(int a1, int a2) 
  : QHsm(Q_STATE_CAST(&Motor::initial)),
    A1(a1),
    A2(a2)
{
}

// @(/2/1/3) .................................................................
void Motor::update(int8_t speed) {
    if (speed == 0)
    {
        brake();
    }
    else if (speed > 0)
    {
        forward(/*speed*/); // no PWM yet :(
    }
    else
    {
        backward();
    }
}
// @(/2/1/4) .................................................................
void Motor::brake() {
    digitalWrite(A1, LOW);
    digitalWrite(A2, LOW);
}
// @(/2/1/5) .................................................................
void Motor::forward() {
    digitalWrite(A1, HIGH);
    digitalWrite(A2, LOW);
}
// @(/2/1/6) .................................................................
void Motor::backward() {
    digitalWrite(A1, LOW);
    digitalWrite(A2, HIGH);
}
// @(/2/1/7) .................................................................
void Motor::init_pins() {
    pinMode(A1, OUTPUT);
    pinMode(A2, OUTPUT);
}
// @(/2/1/8) .................................................................
// @(/2/1/8/0)
QP::QState Motor::initial(Motor * const me, QP::QEvt const * const e) {
    me->init_pins();
    return Q_TRAN(&Motor::attached);
}
// @(/2/1/8/1) ...............................................................
QP::QState Motor::attached(Motor * const me, QP::QEvt const * const e) {
    QP::QState status;
    switch (e->sig) {
        // @(/2/1/8/1)
        case Q_ENTRY_SIG: {
            std::cout << "------Motor: attached." << std::endl;
            me->brake();
            status = Q_HANDLED();
            break;
        }
        // @(/2/1/8/1/0)
        case UPDATE_MOTOR_SPEED_SIG: {
            status = Q_HANDLED();
            break;
        }
        default: {
            status = Q_SUPER(&QHsm::top);
            break;
        }
    }
    return status;
}


} /* namespace Rover */

