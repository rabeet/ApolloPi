//////////////////////////////////////////////////////////////////////////////
// Model: apollo_pi.qm
// File:  ./src/motor_controller.cpp
//
// This file has been generated automatically by QP Modeler (QM).
// DO NOT EDIT THIS FILE MANUALLY.
//
// Please visit www.state-machine.com/qm for more information.
//////////////////////////////////////////////////////////////////////////////
#include "qp_port.h"
#include "rover.h"

#include <wiringPi.h>
#include <iostream>

namespace ApolloPi {

static MotorController l_motorController;
QP::QActive * const AO_MotorController = (QP::QActive *)&l_motorController;

// Motor state machines
static Motor l_leftMotor(2, 3),
             l_rightMotor(4, 5);

// opaque pointers
QP::QHsm * const HSM_LeftMotor = &l_leftMotor;
QP::QHsm * const HSM_RightMotor = &l_rightMotor;

// @(/2/0) ...................................................................
// @(/2/0/2) .................................................................
MotorController::MotorController() 
  : QActive(Q_STATE_CAST(&MotorController::initial))
{
}

// @(/2/0/3) .................................................................
void MotorController::update_motors(MotorControllerEvt * mce) {
    int8_t speed = mce->get_right_speed();

    if (speed < 0)
    {
        digitalWrite(DIRECTION, HIGH);
    }
    else
    {
        digitalWrite(DIRECTION, LOW);
    }

    int pwm = 0x7F & (speed>0)?speed:-speed;

    // normalize
    pwm = pwm/127.0 * 1023;
    std::cout << "PWM: " << pwm << " ("
        << ((pwm/1023.0)*100) << "%)" << std::endl;

    pwmWrite(MOTOR, (speed>0)?pwm:1023-pwm);

    /*
    int8_t left_speed = mce->get_left_speed();
    int8_t right_speed = mce->get_right_speed();

    // dispatch directed to the motors
    ((Motor *)HSM_LeftMotor)->update(left_speed);
    ((Motor *)HSM_RightMotor)->update(right_speed);
    */
}
// @(/2/0/4) .................................................................
void MotorController::brake() {
    // disable motor circuit
    digitalWrite(DIRECTION, LOW);
    pwmWrite(MOTOR, 0);

    std::cout << "MOTORS OFF" << std::endl;
}
// @(/2/0/5) .................................................................
void MotorController::enable() {
    //digitalWrite(ENABLE, HIGH);
}
// @(/2/0/6) .................................................................
void MotorController::init_pins() {
    pinMode(DIRECTION, OUTPUT);
    pinMode(MOTOR, PWM_OUTPUT);

    std::cout << "Motor pins inititalized." << std::endl;
    pwmWrite(MOTOR, 0);
}
// @(/2/0/7) .................................................................
// @(/2/0/7/0)
QP::QState MotorController::initial(MotorController * const me, QP::QEvt const * const e) {
    return Q_TRAN(&MotorController::initialized);
}
// @(/2/0/7/1) ...............................................................
QP::QState MotorController::initialized(MotorController * const me, QP::QEvt const * const e) {
    QP::QState status;
    switch (e->sig) {
        // @(/2/0/7/1)
        case Q_ENTRY_SIG: {
            me->init_pins();
            std::cout << "***MotorController: Initialized***" << std::endl;

            HSM_LeftMotor->init();
            HSM_RightMotor->init();

            me->enable(); // enable pins
            status = Q_HANDLED();
            break;
        }
        // @(/2/0/7/1/0)
        case UPDATE_MOTORS_SIG: {
            std::cout << "MotorController: Updating speed." << std::endl;

            MotorControllerEvt *mce = (MotorControllerEvt *)e;


            if (mce->get_right_speed() == 0)
            {
                me->brake();
            }
            else
            {
                me->update_motors( mce );
            }
            status = Q_HANDLED();
            break;
        }
        default: {
            status = Q_SUPER(&QHsm::top);
            break;
        }
    }
    return status;
}

// @(/3/6) ...................................................................
// @(/3/6/2) .................................................................
void MotorControllerEvt::set_left_speed(int8_t value) {
    left_speed_ = value;
}
// @(/3/6/3) .................................................................
void MotorControllerEvt::set_right_speed(int8_t value) {
    right_speed_ = value;
}
// @(/3/6/4) .................................................................
int8_t MotorControllerEvt::get_left_speed() {
    return left_speed_;
}
// @(/3/6/5) .................................................................
int8_t MotorControllerEvt::get_right_speed() {
    return right_speed_;
}

} /* namespace Rover */
